
单核CPU----同一时刻只能干一件事情。单核多进程实现有两种。
	调度算法两种：
	1）时间片轮转：
		操作系统通过时间片轮转来实现多进程：
		
			1、把每个进程分割成一个个的小段时间
			2、小段时间轮询各个进程。
			3、切换速度非常快，感觉无间隔执行

	2）优先级调度：


多核：
	并发：看上去一起执行。当前执行的程序数量大于多核数目。
	并行：实际上一起执行。实际多核同时执行的程序数目。==核数。



进程：
	程序：一个可执行的代码。就是一坨代码，硬盘上010101的东西。

	进程：当程序运行起来之后，除了代码之外，还会拥有一些资源。
		（把代码加载到内存中，已经分配内存和资源，整个环境，就是进程。）
		比如说占用内存，键盘，显示器，以及其他资源。整个环境构成了一个进程。

		实例：比如：一个exe程序文件，没有双击就是程序，双击运行了，就是进程。

			没运行之前叫程序，运行之后叫进程。
			程序是没有生命的，进程是有生命的。



一、仅用于Unix和linux环境下的fork()
import os 
import time

ret = os.fork()    # 当程序运行到此处os.fork()，会创建一个新的进程。此时有两个进程。
				   # 两个进程都会对ret有一个返回值，其中原进程返回值大于零，新进程返回值为零。
if ret==0:         # 此处原进程不符合条件进入else,新进程符合条件执行if。两个进程同时执行，同时打印1和2。
				   # 这是多任务最核心的地方。多个进程，每个进程都有自己的返回值和执行的地方。产生新进程就是fork
	while True:
		print("----1----")
		time.sleep(1)

else:
	while True:
		print("----2----")
		time.sleep(1)
主进程：进程执行中创建新的进程。那么：
	原进程：称谓：父进程
	新进程：称谓：子进程

核心：
ret = os.fork()  
	这一行代码：os.fork()执行完，创建一个新的进程，此时两个进程。
	两个进程再去执行赋值语句：
		分别执行返回值给ret：
			父进程的ret>0。
			子进程的ret=0.

	其中：父进程创建了子进程，不一定父进程先执行，
		执行顺序是由操作系统的调度算法决定。

	主进程fork返回的值为创建的子进程的Pid !!!!!!!!

	主进程不会等待子进程是否执行完。
	os.fork()之后的代码：两个进程都会各自执行一遍。例码：
	import os
	import time


	ret = os.fork()
"
	if ret==0:
		print("----子进程1-----")
		time.sleep(5)
		print("----子进程2-----")

	else:
		print("----父进程-----")
		time.sleep(3)
	print("----over----")    # 此处会打印两次，父子进程各自打印一遍。



	多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响。

	fork炸弹：
		while True:
			os.fork()迅速沾满所有内存。



二、跨平台下的多进程。 from multiprocessing import Process

	p = Process
	p.start()
	p.join()    # 堵塞：主进程等待子进程完成才往下运行，如果子进程不停，那么将一直处于没完没了状态。
				#		等待的状态称谓堵塞。条件达到才进行下去。条件执行中为堵塞。join([timeout])


创建多任务的三种方法：
	1、通过Process类创建对象。
	2、通过创建Process子类创建对象。class MyNewProcess(Process):
	3、进程池

		池的作用一般就是缓存。缓存数据用的。
		
		进程池：
			  就是创建一堆进程，等着你用。而不是等着用的时候再去创建。
			  节省了创建进程的时间。不用重新创建进程。

		pool.close()  # 关闭进程池，只是不能再次添加新任务了，池关闭了，不接新任务了。
		pool.join()   # 主进程  创建/添加 任务后，主进程 默认不会等待进程池中的任务执行完后才结束。
					  # 而是当 主进程 的任务完成后，立马结束。 
					  # 后果======>>>>>如果没有这个join，会导致进程池中的任务不会再执行。
		pool.apply_async()   非堵塞
		pool.apply()    	 堵塞：几乎不用。

			注意事项：
				Pool(Num_process):Num_process并非说：越多越好：
					Num_process越多：
						1、创建进程，占用的资源越多。
						2、轮询时间越长，总时间越长。
					要根据系统版本和内核数目，经过压力测试，模拟多用户多任务测试完成。


三种方式比较：
	1、Unix/Linux中fork()：父子进程合力。
		ret = os.fork()
		if ret==0:
			# 子进程
		else:
			# 父进程

	2、跨平台：Process
		p1 = Process(target=worker1)
		p2 = Process(target=worker2)

	3、pool = Pool(3)
	  pool.apply_async(work[i])
	  	主进程一般用来等待,,,,,,,真正的任务都在子进程中执行。


	当需要创建的子进程数量不多时，直接利用multiprocessing中的Process动态生成多个进程。
	如果是上百甚至上千个目标，手动创建进程的工作量巨大，此时就用multiprocessing模块提供的Pool方法。



进程间的通信：
	场景：
		一个进程 负责从网上下载数据，
		一个进程 负责处理下载的数据。
		一个进程 负责保存到数据库
		一个进程 负责动态显示到大屏上

		进程间需要通信。通信方式有很多。
			Process需要用到 队列Queue()。 管道。
			进程池Pool的通信通过Manager.Queue()



通过实际测试：
	多进程写文件并没有加速：
		# 因为写文件的瓶颈在磁盘IO，不在CPU，你并行了有毛用……
		#
		# 机械硬盘的悬臂寻址，你并行越多寻址次数越多，性能反而成指数级下降
		# CPU大概比二级缓存快1个数量级，二级缓存大概比内存快1-2个数量级，内存大概比硬盘（极限速度）快2个数量级，而机械硬盘的磁头寻址大概是ms级，磁头寻址一次，CPU能跑大约百万条指令
		#
		# 换句话说，胡乱并行机械硬盘的I/O，多一次磁头寻址，意味着浪费了百万条CPU指令时间


线程：


	多开：多个进程。多个QQ一起开。一个软件一个进程。

	一个软件做多个事情：一个QQ可以开启多个窗口。杀毒软件，既可以杀毒扫描，又可以垃圾清理。

	程序：一个可执行的代码。就是一坨代码，硬盘上010101的东西。

	进程：是资源分配的单位。
	线程：是进程里面真正执行任务的真正执行代码的东西。

	进程：是资源分配的单位。
	线程：是CPU调度的单位。

	程序一运行起来：就有线程，这个是主线程。
	运行程序：操作系统真正调度执行的是线程。


	Thread：
		用Thread创建出来的线程，即使主线程结束了，主线程也不会退出。主线程的目的是：等着子线程真正执行完之后，主线程才会结束。


	总结一个概念：什么叫主线程：
		一个程序运行起来之后：称之为进程：进程会占用内存等等，就是说拥有很多资源。代码从上到下的顺序运行中，（虚拟一个运行顺序的指向箭头，这个箭头指向哪里，就相当于从哪里运行。），这个顺序执行可以看成一个主线程。

			当箭头或说 主线程 运行到t=Thread(target=test), 并且t.start时， 就创建了一个子线程。 子线程去target指向中运行，子线程运行中，主线程继续执行。
			主线程、主进程，不能先结束，是因为要等着子进程、子线程结束，回收资源：等着给孩子们收尸。。
				如果一个子进程结束了，父进程没有回收资源，那么： 僵尸进程。
				如果一个父进程结束了，而子进程没有结束，那么：   孤儿进程。
					此时就需要操作系统的进程：
						PID=0：用来切换进程占用CPU         切换任务。
						PID=1：间接或直接创建所有进程的。    进程收容所。打理一切异常进程。


	如果多个线程同时执行一个函数，不会有问题。


	实现线程多任务的第二种方式：
		重写Thread类。封装各种属性和功能。print(self.name)输出线程名：从Thread 1开始

		length = len(threading.enumerate())   线程长度：

	线程之间，共享全局变量。

	