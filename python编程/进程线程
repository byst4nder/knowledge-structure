
单核CPU----同一时刻只能干一件事情。单核多进程实现有两种。
	调度算法两种：
	1）时间片轮转：
		操作系统通过时间片轮转来实现多进程：
		
			1、把每个进程分割成一个个的小段时间
			2、小段时间轮询各个进程。
			3、切换速度非常快，感觉无间隔执行

	2）优先级调度：


多核：
	并发：看上去一起执行。当前执行的程序数量大于多核数目。
	并行：实际上一起执行。实际多核同时执行的程序数目。==核数。



进程：
	程序：一个可执行的代码。

	进程：当程序运行起来之后，除了代码之外，还会拥有一些资源。
		比如说占用内存，键盘，显示器，以及其他资源。整个环境构成了一个进程。

		实例：比如：一个exe程序文件，没有双击就是程序，双击运行了，就是进程。

			没运行之前叫程序，运行之后叫进程。
			程序是没有生命的，进程是有生命的。



一、仅用于Unix和linux环境下的fork()
import os 
import time

ret = os.fork()    # 当程序运行到此处os.fork()，会创建一个新的进程。此时有两个进程。
				   # 两个进程都会对ret有一个返回值，其中原进程返回值大于零，新进程返回值为零。
if ret==0:         # 此处原进程不符合条件进入else,新进程符合条件执行if。两个进程同时执行，同时打印1和2。
				   # 这是多任务最核心的地方。多个进程，每个进程都有自己的返回值和执行的地方。产生新进程就是fork
	while True:
		print("----1----")
		time.sleep(1)

else:
	while True:
		print("----2----")
		time.sleep(1)
主进程：进程执行中创建新的进程。那么：
	原进程：称谓：父进程
	新进程：称谓：子进程

核心：
ret = os.fork()  
	这一行代码：os.fork()执行完，创建一个新的进程，此时两个进程。
	两个进程再去执行赋值语句：
		分别执行返回值给ret：
			父进程的ret>0。
			子进程的ret=0.

	其中：父进程创建了子进程，不一定父进程先执行，
		执行顺序是由操作系统的调度算法决定。

	主进程fork返回的值为创建的子进程的Pid !!!!!!!!

	主进程不会等待子进程是否执行完。
	os.fork()之后的代码：两个进程都会各自执行一遍。例码：
	import os
	import time


	ret = os.fork()
"
	if ret==0:
		print("----子进程1-----")
		time.sleep(5)
		print("----子进程2-----")

	else:
		print("----父进程-----")
		time.sleep(3)
	print("----over----")    # 此处会打印两次，父子进程各自打印一遍。



	多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响。

	fork炸弹：
		while True:
			os.fork()迅速沾满所有内存。



二、跨平台下的多进程。 from multiprocessing import Process

	p = Process
	p.start()
	p.join()    # 堵塞：主进程等待子进程完成才往下运行，如果子进程不停，那么将一直处于没完没了状态。
				#		等待的状态称谓堵塞。条件达到才进行下去。条件执行中为堵塞。join([timeout])


创建多任务的三种方法：
	1、通过Process类创建对象。
	2、通过创建Process子类创建对象。class MyNewProcess(Process):
	3、进程池

		池的作用一般就是缓存。缓存数据用的。
		
		进程池：
			  就是创建一堆进程，等着你用。而不是等着用的时候再去创建。
			  节省了创建进程的时间。不用重新创建进程。

		pool.close()  # 关闭进程池，只是不能再次添加新任务了，池关闭了，不接新任务了。
		pool.join()   # 主进程  创建/添加 任务后，主进程 默认不会等待进程池中的任务执行完后才结束。
					  # 而是当 主进程 的任务完成后，立马结束。 
					  # 后果======>>>>>如果没有这个join，会导致进程池中的任务不会再执行。
		pool.apply_async()   非堵塞
		pool.apply()    	 堵塞：几乎不用。

			注意事项：
				Pool(Num_process):Num_process并非说：越多越好：
					Num_process越多：
						1、创建进程，占用的资源越多。
						2、轮询时间越长，总时间越长。
					要根据系统版本和内核数目，经过压力测试，模拟多用户多任务测试完成。


三种方式比较：
	1、Unix/Linux中fork()：父子进程合力。
		ret = os.fork()
		if ret==0:
			# 子进程
		else:
			# 父进程

	2、跨平台：Process
		p1 = Process(target=worker1)
		p2 = Process(target=worker2)

	3、pool = Pool(3)
	  pool.apply_async(work[i])
	  	主进程一般用来等待,,,,,,,真正的任务都在子进程中执行。


	当需要创建的子进程数量不多时，直接利用multiprocessing中的Process动态生成多个进程。
	如果是上百甚至上千个目标，手动创建进程的工作量巨大，此时就用multiprocessing模块提供的Pool方法。





进程间的通信：
	场景：
		一个进程 负责从网上下载数据，
		一个进程 负责处理下载的数据。
		一个进程 负责保存到数据库
		一个进程 负责动态显示到大屏上

		进程间需要通信。通信方式有很多。
			Process需要用到 队列Queue()。 管道。
			进程池Pool的通信通过Manager.Queue()



线程：

